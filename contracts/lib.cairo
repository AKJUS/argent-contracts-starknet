mod tests;

mod spans;
mod calls;
mod asserts;

mod argent_account;
use argent_account::ArgentAccount;

mod signer_signature;
mod argent_multisig_account;
use argent_multisig_account::ArgentMultisigAccount;

mod erc20;
use erc20::ERC20;

mod test_dapp;
use test_dapp::TestDapp;

// TODO Delete all under this when automatically generated by Framework
use serde::Serde;
use array::ArrayTrait;

use starknet::StorageAccess;
use starknet::ContractAddress;
use starknet::contract_address::ContractAddressSerde;

use argent_account::ArgentAccount::Escape;
use calls::Call;

impl StorageAccessEscape of StorageAccess::<Escape> {
    fn read(
        address_domain: felt, base: starknet::StorageBaseAddress
    ) -> starknet::SyscallResult<Escape> {
        Result::Ok(
            Escape {
                active_at: (StorageAccess::read(address_domain, base)?),
                escape_type: starknet::storage_read_syscall(
                    address_domain, starknet::storage_address_from_base_and_offset(base, 1_u8)
                )?,
            }
        )
    }
    fn write(
        address_domain: felt, base: starknet::StorageBaseAddress, value: Escape
    ) -> starknet::SyscallResult<()> {
        StorageAccess::write(address_domain, base, value.active_at)?;
        starknet::storage_write_syscall(
            address_domain,
            starknet::storage_address_from_base_and_offset(base, 1_u8),
            value.escape_type
        )
    }
}

impl EscapeSerde of Serde::<Escape> {
    fn serialize(ref serialized: Array<felt>, input: Escape) {
        Serde::serialize(ref serialized, input.active_at);
        Serde::serialize(ref serialized, input.escape_type);
    }
    fn deserialize(ref serialized: Span<felt>) -> Option<Escape> {
        Option::Some(
            Escape {
                active_at: Serde::deserialize(ref serialized)?,
                escape_type: Serde::deserialize(ref serialized)?,
            }
        )
    }
}

impl CallSerde of Serde::<Call> {
    fn serialize(ref serialized: Array::<felt>, input: Call) {
        let ref_input = @input;
        Serde::serialize(ref serialized, *ref_input.to);
        Serde::serialize(ref serialized, *ref_input.selector);
        Serde::serialize(ref serialized, input.calldata);
    }
    fn deserialize(ref serialized: Span::<felt>) -> Option::<Call> {
        Option::Some(
            Call {
                to: Serde::deserialize(ref serialized)?,
                selector: Serde::deserialize(ref serialized)?,
                calldata: Serde::deserialize(ref serialized)?,
            }
        )
    }
}

impl ArrayCallSerde of Serde::<Array::<Call>> {
    fn serialize(ref serialized: Array<felt>, mut input: Array<Call>) {
        Serde::serialize(ref serialized, input.len());
        serialize_array_call_helper(ref serialized, ref input);
    }
    fn deserialize(ref serialized: Span<felt>) -> Option<Array<Call>> {
        let length = Serde::deserialize(ref serialized)?;
        let mut arr = ArrayTrait::new();
        deserialize_array_call_helper(ref serialized, arr, length)
    }
}

fn serialize_array_call_helper(ref serialized: Array<felt>, ref input: Array<Call>) {
    match input.pop_front() {
        Option::Some(value) => {
            Serde::serialize(ref serialized, value);
            serialize_array_call_helper(ref serialized, ref input);
        },
        Option::None(_) => {},
    }
}

fn deserialize_array_call_helper(
    ref serialized: Span<felt>, mut curr_output: Array<Call>, remaining: felt
) -> Option<Array<Call>> {
    if remaining == 0 {
        return Option::Some(curr_output);
    }
    curr_output.append(Serde::deserialize(ref serialized)?);
    deserialize_array_call_helper(ref serialized, curr_output, remaining - 1)
}

